package com.opower.persistence.jpile.loader;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Collection;
import java.util.Date;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.opower.persistence.jpile.infile.InfileDataBuffer;
import com.opower.persistence.jpile.infile.InfileRow;
import com.opower.persistence.jpile.reflection.PersistenceAnnotationInspector;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static com.google.common.base.Throwables.propagate;
import static com.google.common.collect.Maps.newLinkedHashMap;
import static com.google.common.collect.Maps.newTreeMap;
import static com.google.common.collect.Sets.newLinkedHashSet;
import static com.opower.persistence.jpile.reflection.CacheablePersistenceAnnotationInspector.getIdValue;
import static com.opower.persistence.jpile.reflection.CacheablePersistenceAnnotationInspector.setIdValue;

/**
 * An InfileObjectLoader which will update that database using IN FILE format using hibernate annotations.
 *
 * @param <E> the type of object which this class will support
 * @author amir.raminfar
 */
public class SingleInfileObjectLoader<E> extends InfileObjectLoader<E> {
    private static Logger logger = LoggerFactory.getLogger(SingleInfileObjectLoader.class);

     // @TODO we may need to make this atomic to be thread safe
    protected long autoGeneratedId = 0;
    protected final Map<String, Method> mappings = newTreeMap(String.CASE_INSENSITIVE_ORDER);
    protected final Map<Method, SingleInfileObjectLoader<Object>> embeds = newLinkedHashMap();

    protected final Class<E> aClass;
    protected PersistenceAnnotationInspector persistenceAnnotationInspector;
    protected boolean allowNull = false;
    protected boolean autoGenerateId = false;
    protected boolean embedChild = false;

    SingleInfileObjectLoader(Class<E> aClass) {
        this.aClass = aClass;
    }

    /**
     * If the object doesn't have an id it will create a generate a new id. Then it will save the data to the infileRow.
     */
    @Override
    public void convertToInfileRow(E entity, InfileRow infileRow) {
        if(entity == null && allowNull) {
            for(int i = 0; i < mappings.size(); i++) {
                infileRow.appendNull();
            }
            for(SingleInfileObjectLoader<Object> loader : embeds.values()) {
                loader.convertToInfileRow(null, infileRow);
            }
        }
        else {
            if(!embedChild && getIdValue(persistenceAnnotationInspector, entity) == null) {
                generateAndSetId(entity);
            }
            for(Method m : mappings.values()) {
                Object object = invoke(m, entity);
                if(object != null) {
                    if(persistenceAnnotationInspector.hasTableAnnotation(object.getClass())) {
                        Long id = (Long) getIdValue(persistenceAnnotationInspector, object);
                        Preconditions.checkState(id != null, "@Id for [%s] is null", object);
                        object = id;
                    }
                    if(object instanceof Date) {
                        infileRow.append((Date) object);
                    }
                    else if(object instanceof Boolean) {
                        infileRow.append((Boolean) object);
                    }
                    else if(object instanceof byte[]) {
                        infileRow.append((byte[]) object);
                    }
                    else {
                        infileRow.append(object);
                    }
                }
                else {
                    infileRow.appendNull();
                }
            }
            for(Map.Entry<Method, SingleInfileObjectLoader<Object>> entry : embeds.entrySet()) {
                Object object = invoke(entry.getKey(), entity);
                entry.getValue().convertToInfileRow(object, infileRow);
            }
        }
    }

    @Override
    public void flush() {
        long start = System.nanoTime();
        super.flush();
        logger.debug("Elapsed time to flush [{}] to database {}ms",
                     aClass, TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start));
    }

    private void generateAndSetId(E e) {
        if(autoGenerateId) {
            setIdValue(persistenceAnnotationInspector, e, ++autoGeneratedId);
        }
        else {
            throw new IllegalArgumentException(String.format("Illegal state when trying to save [%s]", e));
        }
    }

    private Object invoke(Method method, Object target) {
        try {
            return method.invoke(target);
        }
        catch(InvocationTargetException e) {
            throw propagate(e);
        }
        catch(IllegalAccessException e) {
            throw propagate(e);
        }
    }

    Collection<String> getAllColumns() {
        Set<String> columns = newLinkedHashSet(mappings.keySet());
        for(SingleInfileObjectLoader<Object> loader : embeds.values()) {
            columns.addAll(loader.getAllColumns());
        }
        return columns;
    }

    @VisibleForTesting
    Map<String, Method> getMappings() {
        return mappings;
    }

    @VisibleForTesting
    Map<Method, SingleInfileObjectLoader<Object>> getEmbeds() {
        return embeds;
    }

    @VisibleForTesting
    String getLoadInfileSql() {
        return loadInfileSql;
    }

    @VisibleForTesting
    boolean isAutoGenerateId() {
        return autoGenerateId;
    }

    @VisibleForTesting
    InfileDataBuffer getInfileDataBuffer() {
        return infileDataBuffer;
    }
}
