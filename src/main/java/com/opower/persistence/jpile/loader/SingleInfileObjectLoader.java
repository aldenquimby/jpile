package com.opower.persistence.jpile.loader;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.opower.persistence.jpile.infile.InfileDataBuffer;
import com.opower.persistence.jpile.infile.InfileRow;
import com.opower.persistence.jpile.reflection.PersistenceAnnotationInspector;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.persistence.Column;
import javax.persistence.EnumType;
import javax.persistence.Enumerated;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Collection;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.concurrent.TimeUnit;

import static com.google.common.base.Throwables.propagate;
import static com.google.common.collect.Sets.newLinkedHashSet;
import static com.opower.persistence.jpile.reflection.PersistenceAnnotationInspector.getIdValue;
import static com.opower.persistence.jpile.reflection.PersistenceAnnotationInspector.setIdValue;
import static com.opower.persistence.jpile.util.Hex.encodeHexString;

/**
 * An InfileObjectLoader which will update that database using IN FILE format using hibernate annotations.
 *
 * @param <E> the type of object which this class will support
 * @author amir.raminfar
 */
public class SingleInfileObjectLoader<E> extends InfileObjectLoader<E> {
    private static Logger logger = LoggerFactory.getLogger(SingleInfileObjectLoader.class);

    // @TODO we may need to make this atomic to be thread safe
    protected long autoGeneratedId = 0;
    protected final Map<String, Method> mappings = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
    protected final Map<Method, SingleInfileObjectLoader<Object>> embeds = new LinkedHashMap<>();

    protected final Class<E> aClass;
    protected PersistenceAnnotationInspector persistenceAnnotationInspector;
    protected boolean allowNull = false;
    protected boolean autoGenerateId = false;
    protected boolean embedChild = false;

    SingleInfileObjectLoader(Class<E> aClass) {
        this.aClass = aClass;
    }

    /**
     * If the object doesn't have an id it will create a generate a new id. Then it will save the data to the infileRow.
     */
    @Override
    public void convertToInfileRow(E entity, InfileRow infileRow) {
        if (entity == null && allowNull) {
            for (int i = 0; i < mappings.size(); i++) {
                infileRow.appendNull();
            }
            for (SingleInfileObjectLoader<Object> loader : embeds.values()) {
                loader.convertToInfileRow(null, infileRow);
            }
        }
        else {
            if (!embedChild && getIdValue(persistenceAnnotationInspector, entity) == null) {
                generateAndSetId(entity);
            }
            for (Method m : mappings.values()) {
                Object object = invoke(m, entity);
                if (object != null) {
                    if (persistenceAnnotationInspector.hasTableAnnotation(object.getClass())) {
                        Long id = (Long) getIdValue(persistenceAnnotationInspector, object);
                        Preconditions.checkState(id != null, "@Id for [%s] is null", object);
                        object = id;
                    }
                    if (object instanceof Date) {
                        infileRow.append((Date) object, m);
                    }
                    else if (object instanceof Boolean) {
                        infileRow.append((Boolean) object);
                    }
                    else if (object instanceof byte[]) {
                        infileRow.append(encodeHexString((byte[]) object));
                    }
                    else if (object.getClass().isEnum()) {
                        infileRow.append(getEnumValueToAppend(m, (Enum <?>) object));
                    }
                    else if (object instanceof Float) {
                        Column column = this.persistenceAnnotationInspector.findAnnotation(m, Column.class);
                        if (column != null) {
                            int precision = column.precision();
                            int scale = column.scale();
                            if (precision > 0 && scale > 0) {
                                infileRow.append((Float) object, precision, scale);
                                continue;
                            }
                        }
                        infileRow.append(object);
                    }
                    else {
                        infileRow.append(object);
                    }
                }
                else {
                    infileRow.appendNull();
                }
            }
            for (Map.Entry<Method, SingleInfileObjectLoader<Object>> entry : embeds.entrySet()) {
                Object object = invoke(entry.getKey(), entity);
                entry.getValue().convertToInfileRow(object, infileRow);
            }
        }
    }

    /**
     * Get the enum value depending on if the {@code method} specifies the {@link Enumerated} annotation
     * and if it's an {@link EnumType#STRING} to use the {@link Enum#name()}, otherwise use {@link Enum#ordinal()} as specified
     * in the {@link Enumerated} documentation.
     *
     * @param method the method that returned the {@code enumObject}
     * @param enumObject the enum object that is being appended
     * @return the enum value to append
     */
    @VisibleForTesting
    Object getEnumValueToAppend(Method method, Enum<?> enumObject) {
        Enumerated enumerated = method.getAnnotation(Enumerated.class);
        if(enumerated != null && enumerated.value() == EnumType.STRING) {
            return enumObject.name();
        }

        return enumObject.ordinal();
    }

    @Override
    public void flush() {
        long start = System.nanoTime();
        super.flush();
        logger.debug("Elapsed time to flush [{}] to database {}ms",
                     aClass, TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start));
    }

    private void generateAndSetId(E e) {
        if (autoGenerateId) {
            setIdValue(persistenceAnnotationInspector, e, ++autoGeneratedId);
        }
    }

    private Object invoke(Method method, Object target) {
        try {
            return method.invoke(target);
        }
        catch (InvocationTargetException | IllegalAccessException e) {
            throw propagate(e);
        }
    }

    public void setAutoGeneratedId(long autoGeneratedId) {
        this.autoGeneratedId = autoGeneratedId;
    }

    Collection<String> getAllColumns() {
        Set<String> columns = newLinkedHashSet(mappings.keySet());
        for (SingleInfileObjectLoader<Object> loader : embeds.values()) {
            columns.addAll(loader.getAllColumns());
        }
        return columns;
    }

    @VisibleForTesting
    Map<String, Method> getMappings() {
        return mappings;
    }

    @VisibleForTesting
    Map<Method, SingleInfileObjectLoader<Object>> getEmbeds() {
        return embeds;
    }

    @VisibleForTesting
    boolean isAutoGenerateId() {
        return autoGenerateId;
    }

    @VisibleForTesting
    InfileDataBuffer getInfileDataBuffer() {
        return infileDataBuffer;
    }
}
